// для работы с БД нужно установить пакет mysql - npm i mysql - и импортировать его
const mysql = require('mysql');

/* нужно организовать подключение к БД. Но одного осединения с базой, как правило,
* не достаточно для правильного функционировнаия веб-приложений. Node.JS работает не
* так как синхронные языки. В случае синхронного языка - у нас бы соединение создавалось
* в каждом экземпляре скрпита (PHP), но в ноде создаётся всего лишь один экземпляр скрипта,
* который занимается обработкой всех запросов от всех пользователей. И может сложиться
* такая ситуация, что у нас одновременно два пользователя придут на наш сервис и первый
* пользователь полностью займёт соединение и второму - ничего не достанется. Это неприемлимая
* ситуация. Поэтому создают не одно соединение, а целый пул соединений (набор открытых в
* данный момент соединений, которые сервер поддерживает в актуальном состоянии). И мы
* можем забрать из этого пула любое активное соединение.
* для создания пула вместо const connection = mysql.createConnection() применяют 
* mysql.createPool({})
*/
const pool = mysql.createPool({
  host: 'localhost',
  database: 'tasks',
  user: 'root',
  password: 'Alex123belka',
})

//const name = 'Vasya';

// класс для работы с БД
class Task {
  // создаём методы для работы с данными

  //получим все записи в таблице - SELECT * FROM `tablename`
  static getAll() {
    /* дорогой pool, дай, пожалуйста, нам какое-ниубдь соединение и он в колбэке его нам предоставит))
    * т.е. в любой момент времени мы можем попросить и пула открытое соединение и пул нам передаст его
    * в колбэке. Оборачиваем всё в промис
    */
    return new Promise((resolve, reject) => {
      pool.getConnection((err, connection) => {
        if (err) {
          reject(err);
        }
        //отправляем запрос к базе
        // (sql запрос, callback куда он вернётся)

        connection.query('SELECT * FROM `tasks`', (err, rows) => {
          if (err) {
            reject(err);
          }
          // rows - это экземпляр класса - массив объектов. Имя полей объектов соответствует полям таблиц
          resolve(rows);
          // последним шагом необходимо вернуть соединение обратно в pool. Если не будем возвращать,
          // то рано или поздно соединения в пуле закончится и некоторые пользователи получат отказ в обслуживании
          connection.release();
        })
      })
    })
  }

  /* метод добавления данных. Данные, приходящие извне, должны быть экранированны. Например от xss атак, когда
  * кто-то пишет js код в форму и он после попадания в базу выводится на страничках у других пользователей.
  * Это приведёт к тому, что какой-то непонятный вредоносный код будет выполняться у наших пользователей.
  * Кроме всего прочего надо избежать sql инъекции.
  * На самом деле, в нашем установленном mysql модуле - всё экранирование работает уже из коробки - в библиотеке
  * имеется подготовка запросов
  */
  static add(task) {
    return new Promise((resolve, reject)=>{
      pool.getConnection((err, connection) => {
        if (err) {
          reject(err);
        }
        // при вставке данных применяем синтаксис со знаком ?, вторым параметром указываем объект,
        // который хотим создать. Библиотека mysql автоматически вместо значка вопроса в нужном
        // синтаксисе поставит все данные из объекта task и полностью заэкранирует все результаты
        connection.query('INSERT INTO `tasks` SET ?', task, (err, result) => {
          if (err) {
            reject(err);
          }
          //заресолвить можно айдишник вставленной записи. Также в result есть свойство affected rows
          // для запросов на обновление - если что-то обновляем и хотим проверить сколько строчек было
          // этим затронуто, также есть свойство inserted rows и т.д и т.п
          resolve(result.insertId);
          connection.release();
        })
      })
    })
  }

  static update() {

  }

  static complete() {

  }

  static delete() {

  }
}

/* module.exports - что-то типа ретёрна. У каждого модуля присутствует замыкание как и у обыкновенной функции
т.е. все пременные создаваемые внутри модуля доступны только внутри него.
*/
module.exports = Task;

/* для того, чтобы экспортировать несколько сущностей - нужен объект
module.exports = {
  Task,
  name
}
*/